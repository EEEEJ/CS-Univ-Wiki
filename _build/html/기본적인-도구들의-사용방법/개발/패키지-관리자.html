
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" lang="markdown">
  <head>
    <meta charset="utf-8" />
    <title>패키지 관리자 &#8212; CS Univ Wiki 1.0.0 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <div class="section" id="id1">
<h1>패키지 관리자<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<blockquote>
<div><p>Q : 프로그램을 설치하려면 어떻게 해야할까요?</p>
<p>A : 설치파일을 다운 받고, 실행 시키고, 설치를 하면 되겠죠.</p>
<p>Q : 리눅스에서는요?</p>
<p>A : …...</p>
</div></blockquote>
<p>-nix like[^1]에서 프로그램을 설치하는 방법을 이야기해보자면, 과거에는 소스코드를 다운 받고, ./configure를 이용해서 적합한 Makefile을 만들고, make, make install을 통해서 컴파일을 하여 설치를 하였습니다. 아직도, 이렇게 프로그램 빌드하는 경우가 있습니다.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ ./configure
$ make
$ make install
</pre></div>
</div>
<p>사실 이런 빌드 과정은 프로그램을 컴파일하는 시간도 엄청나게 길었을 뿐만 아니라, 상당히 귀찮은 작업이었습니다. 그래서, 팩키지 단위로 설치를 하는 대안이 나왔고, 그 이후에는 패키지 관리기법도 귀찮아서 앱스토어와 비슷하게 인터넷에서 다운로드까지 자동으로 해주는 녀석들이 나왔습니다. 이제 이것들에 대해서 리눅스 역사 공부도 할 겸 하나하나 살펴보도록 하죠.</p>
<p>[^1]: Unix, Linux 등등...</p>
<div class="section" id="old-way">
<h2>Old way<a class="headerlink" href="#old-way" title="Permalink to this headline">¶</a></h2>
<p>일반적으로 다음과 같은 과정을 거쳐 빌드를 하게 됩니다.</p>
<ol class="simple">
<li><p>웹 상에서 배포되고 있는 .tar.gz 파일들을 다운로드 받은 뒤, tar 명령어를 이용하여 압축을 해제합니다.</p></li>
<li><p>소스코드의 설정 부분들을 입맛에 맛게 수정한 뒤, ./configure 를 이용해서 Makefile을 만들거나, 이미 만들어진 Makefile을 적절하게(?) 수정을 합니다.</p></li>
<li><p>make 명령어를 이용하여 빌드를 시작합니다</p></li>
<li><p>make install을 이용하여 설치를 마무리 합니다</p></li>
</ol>
</div>
<div class="section" id="rpm">
<h2>rpm<a class="headerlink" href="#rpm" title="Permalink to this headline">¶</a></h2>
<p>RPM은 Redhat Package Manager의 줄임말이자 RPM Package Manager의 줄임말입니다. 레드햇 리눅스에서 도입된 패키지 관리자이며, 레드햇 계열 리눅스를 써보셨다면 과거에는 정말 많이 썼던 명령어일 것입니다. 기본적인 사용방법은 원하는 패키지를 인터넷에서 다운 받아서, rpm을 이용하여 팩키지를 설치하거나 업그레이드를 하면 됩니다. 다음과 같은 명령어를 사용해서 말이죠.</p>
<ul>
<li><p>설치</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">rpm</span> <span class="pre">-ivh</span> <span class="pre">패키지명</span></code></p>
</div></blockquote>
</li>
<li><p>설치 확인</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">rpm</span> <span class="pre">-qa</span> <span class="pre">|</span> <span class="pre">grep</span> <span class="pre">패키지명</span></code></p>
</div></blockquote>
</li>
<li><p>제거</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">rpm</span> <span class="pre">-ev</span> <span class="pre">패키지명</span></code></p>
</div></blockquote>
</li>
<li><p>업그레이드</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">rpm</span> <span class="pre">-Uvh</span> <span class="pre">패키지명</span></code></p>
</div></blockquote>
</li>
</ul>
<p>보면 머리가 아프군요. -ivh는 또 뭐고, -qa는 또 뭐고…. 그냥 install, list, remove, upgrade 이렇게 쓰면 안되는 걸까요? 심지어, rpm은 의존성 문제를 자동적으로 해결해주지 않습니다. 그러니까, 예를들어서, rpm으로 A라는 팩키지를 설치할 때, B, C, D가 컴퓨터에 미리 깔려있어야한다고 가정을 해보죠. 즉, C, D가 안 깔려있다면, C, D를 또 깔아줘야합니다. 눈치를 채신분들도 있으시겠지만, C와 D도 의존성이 존재할 거라는 거죠. 다시 말하면, C가 E, F, G를, D가 G, H, I를, E가.... 이런식으로 꼬리를 물면서 팩키지 의존성들이 있으면, 의존성이 있는 팩키지들을 하나하나 다 깔아야한다는 문제가 존재하는 것입니다. 거기다가, C 팩키지는 G 팩키지 1.X 버전을, D 팩키지가 G 팩키지 2.X 버전을 요구한다면 어떻게 하실겁니까? 일반적으로 이것을 의존성 지옥이라고 부릅니다.[^1] 결국 이것에 대한 해결책이 나오기 까진, 아니… 정확히는 데비안 계열에서 이것에 대해서 먼저 해결책을 제시해줬죠. [^2]</p>
<p>이런 일들에 대해서 좀 더 궁금하시다면, 2003년에 KLDP에 올라온 <a class="reference external" href="https://kldp.org/node/24450">여러분들은 의존성이 생길때 어떻게 해결하십니까?</a> 글을 한 번 읽어보시길</p>
<p>[^1]: 설명이 이해가 안되신다면, 정광섭님의 <a class="reference external" href="https://www.lesstif.com/pages/viewpage.action?pageId=26083775">의존성 지옥</a>을 읽어보시길</p>
<p>[^2]: 기억에 의존하는 것임으로 역시 이 또한 명확한 출처 필요</p>
<p>{% include '/틀/작성중.md' %}</p>
</div>
<div class="section" id="yum">
<h2>yum<a class="headerlink" href="#yum" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="dpkg">
<h2>dpkg<a class="headerlink" href="#dpkg" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="apt-get">
<h2>apt-get<a class="headerlink" href="#apt-get" title="Permalink to this headline">¶</a></h2>
<p>아마도 우분투 환경에서 프로그램을 설치하게 된다면, 자주 쓰게 될 명령어일 것입니다. apt-get 하나로 정말 리눅스에서의 생활이 편해지는 걸 느낄 수 있을 것입니다. 많은 오픈소스 프로젝트들을 apt-get 명령어 하나로 다운받고 설치하고 의존성 문제도 깨끗하게 해결되는 걸 볼 수 있습니다. 자 이제 배워보도록 합시다!</p>
</div>
<div class="section" id="brew">
<h2><a class="reference external" href="http://brew.sh/">brew</a><a class="headerlink" href="#brew" title="Permalink to this headline">¶</a></h2>
<p>리눅스 진영에 yum과 apt-get이 있다면, OS X 진영에는 Fink, MacPort, Homebrew 등등이 있습니다. 그 중에서도, 현재 OS X 진영에서 제일 쓸만한 녀석은 Homebrew 일 것입니다. 까는 방법도 상당히 쉽습니다. 터미널에서 <a class="reference external" href="http://brew.sh/">홈브류 홈페이지</a>에 올라온 명령어만 치고 잠시 기다리면 됩니다.</p>
<p>기본적인 사용방법은 apt-get과 상당히 비슷합니다만,  brew에서는 tap과 caskroom이라는 개념이 존재합니다. 예제를 통해 각각의 기능들 살펴보도록 하겠습니다.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ brew <span class="nb">help</span>
Example usage:
  brew search <span class="o">[</span>TEXT<span class="p">|</span>/REGEX/<span class="o">]</span>
  brew <span class="o">(</span>info<span class="p">|</span>home<span class="p">|</span>options<span class="o">)</span> <span class="o">[</span>FORMULA...<span class="o">]</span>
  brew install FORMULA...
  brew update
  brew upgrade <span class="o">[</span>FORMULA...<span class="o">]</span>
  brew uninstall FORMULA...
  brew list <span class="o">[</span>FORMULA...<span class="o">]</span>

Troubleshooting:
  brew config
  brew doctor
  brew install -vd FORMULA

Developers:
  brew create <span class="o">[</span>URL <span class="o">[</span>--no-fetch<span class="o">]]</span>
  brew edit <span class="o">[</span>FORMULA...<span class="o">]</span>
  https://github.com/Homebrew/brew/blob/master/docs/Formula-Cookbook.md

Further help:
  man brew
  brew <span class="nb">help</span> <span class="o">[</span>COMMAND<span class="o">]</span>
  brew home
<span class="c1"># brew help를 하면 알 수 있듯이, brew &lt;명령어&gt; [옵션] 형태로 명령을 내립니다.</span>
<span class="c1"># 팩키지 검색, 정보 보기, 설치, 설치된 팩키지 보기, 삭제 순으로 실습을 해봅시다.</span>

<span class="c1"># brew로 abc 팩키지 검색</span>
$ brew search abc
abcde                    abcl                     abcm2ps                  abcmidi

<span class="c1"># abc로 검색된 것 중에서 abcde라는 녀석의 정보를 보겠습니다.</span>
$ brew info abcde
abcde: stable <span class="m">2</span>.7.2 <span class="o">(</span>bottled<span class="o">)</span>, HEAD
Better CD Encoder
https://abcde.einval.com
Not installed
From: https://github.com/Homebrew/homebrew-core/blob/master/Formula/abcde.rb
<span class="o">==</span>&gt; Dependencies
Required: cd-discid ✔, cdrtools ✔, id3v2 ✔, mkcue ✔
Optional: flac ✔, lame ✔, vorbis-tools ✘, glyr ✘
<span class="o">==</span>&gt; Options
--with-flac
	Build with flac support
--with-glyr
	Build with glyr support
--with-lame
	Build with lame support
--with-vorbis-tools
	Build with vorbis-tools support
--HEAD
	Install HEAD version

<span class="c1"># brew home 명령어로 abcde의 제작사 홈페이지를 열 수 있습니다.</span>
$ brew home abcde

<span class="c1"># brew install abcde 명령어로 abcde를 설치합니다.</span>
$ brew install <span class="nv">abcde</span>
<span class="o">==</span>&gt; Downloading https://homebrew.bintray.com/bottles/abcde-2.7.2.sierra.bottle.tar.gz
Already downloaded: /Users/BenjiOh5/Library/Caches/Homebrew/abcde-2.7.2.sierra.bottle.tar.gz
<span class="o">==</span>&gt; Pouring abcde-2.7.2.sierra.bottle.tar.gz
🍺  /usr/local/Cellar/abcde/2.7.2: <span class="m">13</span> files, <span class="m">422</span>.7K

<span class="c1"># brew upgrade 명령어로, abcde를 업그레이드 해봅시다. 최신 버전임으로 에러가 뜹니다.</span>
$ brew upgrade abcde
Error: abcde <span class="m">2</span>.7.2 already installed

<span class="c1"># brew는 캐시 파일이 남기 때문에, 설치 후에 cleanup 명령어로 캐시를 날려야합니다.</span>
<span class="c1"># 귀찮다면 brew update; brew upgrade; brew cleanup 으로 명령어들을 하나로 묶어서 쓰는걸 추천합니다.</span>
$ brew cleanup

<span class="c1"># 설치되어있는 팩키지들을 보여줍니다.</span>
$ brew list

<span class="c1"># brew uninstall 로 필요없는 녀석들 삭제합니다.</span>
$ brew uninstall abcde
Uninstalling /usr/local/Cellar/abcde/2.7.2... <span class="o">(</span><span class="m">13</span> files, <span class="m">422</span>.7K<span class="o">)</span>

<span class="c1"># brew update 로 brew의 팩키지 정보를 최신으로 갱신합니다. (자주 합시다!)</span>
$ brew update

<span class="c1"># 참고로 brew upgrade만 치면 모든 팩키지를 업데이트 시도합니다.</span>
$ brew upgrade

<span class="c1"># 즉 다음과 같이 치면, 아주 손쉽게 업그레이드가 가능합니다.</span>
$ brew update <span class="p">;</span> brew upgrade <span class="p">;</span> brew cleanup

<span class="c1"># brew는 tap을 지원합니다.</span>
<span class="c1"># 일종의 확장과도 같은데, Science 탭을 tap하면, Science관련 팩키지들을 다운 받을 수 있습니다.</span>
$ brew tap
aspnet/dnx
caskroom/cask
caskroom/fonts
homebrew/apache
homebrew/binary
homebrew/boneyard
homebrew/command-not-found
homebrew/core
homebrew/dupes
homebrew/fuse
homebrew/games
homebrew/headonly
homebrew/php
homebrew/python
homebrew/science
homebrew/services
homebrew/tex
homebrew/versions
homebrew/x11
jlhonora/lsusb
neovim/neovim
zyedidia/micro

<span class="c1"># 이렇게 탭을 확장할 수 있습니다.</span>
$ brew tap caskroom/fonts
Cloning into <span class="s1">&#39;/usr/local/Homebrew/Library/Taps/caskroom/homebrew-fonts&#39;</span>...
remote: Counting objects: <span class="m">1067</span>, <span class="k">done</span>.
remote: Compressing objects: <span class="m">100</span>% <span class="o">(</span><span class="m">1057</span>/1057<span class="o">)</span>, <span class="k">done</span>.
remote: Total <span class="m">1067</span> <span class="o">(</span>delta <span class="m">220</span><span class="o">)</span>, reused <span class="m">26</span> <span class="o">(</span>delta <span class="m">7</span><span class="o">)</span>, pack-reused <span class="m">0</span>
Receiving objects: <span class="m">100</span>% <span class="o">(</span><span class="m">1067</span>/1067<span class="o">)</span>, <span class="m">259</span>.84 KiB <span class="p">|</span> <span class="m">0</span> bytes/s, <span class="k">done</span>.
Resolving deltas: <span class="m">100</span>% <span class="o">(</span><span class="m">220</span>/220<span class="o">)</span>, <span class="k">done</span>.
Tapped <span class="m">0</span> formulae <span class="o">(</span><span class="m">1</span>,083 files, <span class="m">888</span>.2K<span class="o">)</span>

<span class="c1"># 탭이 필요없다면 다음과 같이 언탭을 하면 됩니다.</span>
$ brew untap caskroom/fonts
Untapping caskroom/fonts... <span class="o">(</span><span class="m">1</span>,168 files, <span class="m">1</span>.4M<span class="o">)</span>
Untapped <span class="m">0</span> formulae

<span class="c1"># Caskroom이라고 CLI 프로그램 뿐만 아니라 앱들도 설치가 가능합니다.</span>
<span class="c1"># 앱스토어에 없는 Alfred, Postman 같은 녀석들을 설치 가능합니다.</span>
<span class="c1"># 기존의 brew 사용법과 동일합니다.</span>
$ brew cask install alfred
$ brew cask unistall alfred
$ brew cask list
$ brew cask tap ...
</pre></div>
</div>
<p>기본적인 명령어를 알아봤습니다. 일반적으로 처음 사용하신다면 install, upgrade, update 만 사용하실거라고 생각됩니다. 기능들은 차차 배워나가면 되고, 개발을 할 때 필요한 녀석들은 대부분 Hombrew에 있음으로 일단 Hombrew에서 검색을 해보고 설치하는 걸 권장합니다. 저는 아직도 Haskell GHC를 dmg로 설치했다가 업그레이드 관련으로 엄청 꼬여서 그냥 방치 중인데, brew로 설치했다면 그런 대 참사는 없었겠죠. 그만큼 팩키지로 관리하는건 중요합니다.</p>
</div>
<div class="section" id="choco">
<h2><a class="reference external" href="https://chocolatey.org/">choco</a><a class="headerlink" href="#choco" title="Permalink to this headline">¶</a></h2>
<p>심지어 윈도우에도 패키지 관리자가 있습니다! Windows 10부터 bash shell이 기본적으로 포함되게 되면서 의미가 많이 퇴색되었지만, 기본적으로 필요한 여러가지 CLI 툴들을 다운 받는데에는 아직도 상당히 요긴합니다. Powershell 환경에서 작업할 때 진가를 발휘하죠. 사실… 그렇게 많이 쓸 일은 없으니 그냥 설치 링크만 적어놓겠습니다.</p>
<p>p.s. 설치 가능한 팩키지들이 상당히 <a class="reference external" href="https://chocolatey.org/packages">독특</a>하니 한 번 보시길 바랍니다.</p>
</div>
<div class="section" id="pip">
<h2>pip<a class="headerlink" href="#pip" title="Permalink to this headline">¶</a></h2>
<p>pip은 파이썬 팩키지 관리자입니다.</p>
<ul class="simple">
<li><p>윈도우 환경에서는 pip이 안 깔려있어 수동으로 깔아야만 했으나, 현재는 python을 설치할 때 같이 깔리게 됩니다.</p></li>
<li><p>리눅스 및 OS X 환경에서는 기본적으로 python과 pip이 설치되어 있음으로 그냥 사용하시면 됩니다.</p></li>
<li><p>다만, OS X의 경우 Homebrew와 같은 팩키지 관리자로 python과 pip을 새로 설치하여 쓰는 것을 권장합니다.</p></li>
</ul>
<p>pip은 다른 팩키지 관리자와 사용 방법이 거의 동일합니다.</p>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ pip <span class="nb">help</span>

Usage:
  pip &lt;command&gt; <span class="o">[</span>options<span class="o">]</span>

Commands:
  install                     Install packages.
  download                    Download packages.
  uninstall                   Uninstall packages.
  freeze                      Output installed packages in requirements format.
  list                        List installed packages.
  show                        Show information about installed packages.
  search                      Search PyPI <span class="k">for</span> packages.
  wheel                       Build wheels from your requirements.
  <span class="nb">hash</span>                        Compute hashes of package archives.
  completion                  A helper <span class="nb">command</span> used <span class="k">for</span> <span class="nb">command</span> completion
  <span class="nb">help</span>                        Show <span class="nb">help</span> <span class="k">for</span> commands.

<span class="c1"># pip help를 하면 알 수 있듯이, pip &lt;명령어&gt; [옵션] 형태로 명령을 내립니다.</span>
<span class="c1"># 팩키지 검색, 설치, 설치된 팩키지 보기, 정보 보기, 삭제 순으로 실습을 해봅시다.</span>
<span class="c1"># pip으로 abc1 팩키지 검색</span>
$ pip search abc1
abc1 <span class="o">(</span><span class="m">1</span>.2.0<span class="o">)</span>  - a list about my think

<span class="c1"># pip으로 abc1 팩키지 설치</span>
$ pip install abc1
Collecting abc1
  Downloading abc1-1.2.0.zip
Building wheels <span class="k">for</span> collected packages: abc1
  Running setup.py bdist_wheel <span class="k">for</span> abc1 ... <span class="k">done</span>
  Stored in directory: 
  <span class="o">[</span>Censored<span class="o">]</span>
Successfully built abc1
Installing collected packages: abc1
Successfully installed abc1-1.2.0

<span class="c1"># pip으로 설치된 abc1 팩키지 정보 보기</span>
$ pip show abc1
---
Metadata-Version: <span class="m">2</span>.0
Name: abc1
Version: <span class="m">1</span>.2.0
Summary: a list about my think
Home-page: http://www.sheooo.com
Author: yangfeng
Author-email: <span class="o">[</span>Censored<span class="o">]</span>
Installer: pip
License: UNKNOWN
Location: /usr/local/lib/python2.7/site-packages
Requires:
Classifiers:

<span class="c1"># pip으로 abc1 팩키지 삭제</span>
$ pip uninstall abc1
Uninstalling abc1-1.2.0:
  /usr/local/lib/python2.7/site-packages/abc1-1.2.0.dist-info/DESCRIPTION.rst
  /usr/local/lib/python2.7/site-packages/abc1-1.2.0.dist-info/INSTALLER
  /usr/local/lib/python2.7/site-packages/abc1-1.2.0.dist-info/METADATA
  /usr/local/lib/python2.7/site-packages/abc1-1.2.0.dist-info/RECORD
  /usr/local/lib/python2.7/site-packages/abc1-1.2.0.dist-info/WHEEL
  /usr/local/lib/python2.7/site-packages/abc1-1.2.0.dist-info/metadata.json
  /usr/local/lib/python2.7/site-packages/abc1-1.2.0.dist-info/top_level.txt
  /usr/local/lib/python2.7/site-packages/abc1.py
Proceed <span class="o">(</span>y/n<span class="o">)</span>? y
  Successfully uninstalled abc1-1.2.0

<span class="c1"># 솔직히 이런식으로 예제를 적을 필요가 있는가에 대해서 심각하게 고민을 했으나,</span>
<span class="c1"># 저는 학우 여러분을 믿지 않음으로 다 적습니다.</span>
</pre></div>
</div>
<p>그렇다면, 이제 pip이 왜 존재하는가에 대해서 생각을 해볼차례겠네요. 사실 pip은 파이썬 개발에 있어서 아주 큰 축을 담당하고 있습니다. __라이브러리의 다운로드 및 관리__를 말이죠. 파이썬 라이브러리들은 pip을 통해 손쉽게 설치가 되고, 삭제가 될 수 있습니다. 즉, 코딩하다가 <em>이런이런게 필요한데…</em> 라는 생각이 들 경우, 그 상황에 적합한 파이썬 라이브러리를 찾고, pip으로 다운로드를 하면 모든게 끝입니다. 짜고 있던 코드에서 <code class="docutils literal notranslate"><span class="pre">import</span> <span class="pre">&quot;lib_what_you_want&quot;</span> </code>해주면, 라이브러리를 임포트 하고, 그 라이브러리를 사용해서 코딩을 하면 되죠. 그렇다면, 배포할 때에 상대방이 라이브러리가 없다면 어떻게해야할까요? 이는 일반적으로 requirements.txt 같은 라이브러리 요구사항을 적은 파일을 만들어 놓고, <code class="docutils literal notranslate"><span class="pre">pip</span> <span class="pre">install</span> <span class="pre">-U</span> <span class="pre">-r</span> <span class="pre">requirements.txt</span></code>를 하여 필요한 라이브러리를 설치하도록 하던지, 팩키지 관리자로 배포를 하면서, 의존성에 관한 파트를 기술하여, 사용하는 라이브러리도 자동으로 다운받도록 하는 방법이 있습니다.</p>
<p>{% include &quot;/틀/작성중.md&quot; %}</p>
</div>
<div class="section" id="gem">
<h2>gem<a class="headerlink" href="#gem" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="npm">
<h2>npm<a class="headerlink" href="#npm" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="bower">
<h2>bower<a class="headerlink" href="#bower" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="gulp">
<h2>gulp<a class="headerlink" href="#gulp" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="grunt">
<h2>grunt<a class="headerlink" href="#grunt" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="pkg-ng">
<h2>pkg(ng)<a class="headerlink" href="#pkg-ng" title="Permalink to this headline">¶</a></h2>
<p>Pkg는 FreeBSD 10.0-RELEASE와 함께 추가된 패키지 관리자입니다. 사실 정확한 이름은 pkgng로, <em>PKG</em> <em>N</em>ext <em>G</em>eneration을 표방합니다. 물론 이전에도 pkg라는 패키지 관리자가 있긴 했지만, 단일 프로그램이 아니라 <code class="docutils literal notranslate"><span class="pre">pkg_info</span></code>나 <code class="docutils literal notranslate"><span class="pre">pkg_add</span></code> 같은 군소 프로그램의 집합[^1]으로 존재했습니다. PkgNG는 단일 프로그램 <code class="docutils literal notranslate"><span class="pre">pkg</span></code>로 모든 기능이 합쳐진 결과물입니다.</p>
<p>FreeBSD 시스템을 새로 설치한 직후에는 <code class="docutils literal notranslate"><span class="pre">pkg</span></code>가 시스템에 없습니다. 따라서, Ports Tree[^2]로부터 직접 컴파일해야 합니다. root 계정으로 아래 명령어를 입력해 <code class="docutils literal notranslate"><span class="pre">pkg</span></code>를 설치합시다:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">cd</span> <span class="pre">/usr/ports/ports-mgmt/pkg;</span> <span class="pre">make</span> <span class="pre">install</span> <span class="pre">clean;</span> <span class="pre">cd</span> <span class="pre">-</span></code></p>
</div></blockquote>
<p>이제 시스템에 <code class="docutils literal notranslate"><span class="pre">pkg</span></code>가 존재하니 한 번 사용해봅시다. 자주 사용하는 명령 몇 가지를 정리해보았습니다:</p>
<ul>
<li><p>패키지 설치</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">pkg</span> <span class="pre">install</span> <span class="pre">패키지-이름</span></code></p>
</div></blockquote>
</li>
<li><p>패키지 제거</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">pkg</span> <span class="pre">delete</span> <span class="pre">패키지-이름</span></code></p>
</div></blockquote>
</li>
<li><p>설치된 패키지 전체 목록 보기</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">pkg</span> <span class="pre">version</span></code></p>
</div></blockquote>
</li>
<li><p>업데이트 가능한 패키지만 뽑아보기</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">pkg</span> <span class="pre">version</span> <span class="pre">-vIL=</span></code></p>
</div></blockquote>
</li>
<li><p>패키지 업데이트</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">pkg</span> <span class="pre">upgrade</span> <span class="pre">패키지-이름</span></code></p>
</div></blockquote>
</li>
</ul>
<p>[^1]: 비슷한 사례가 위에서 다룬 <code class="docutils literal notranslate"><span class="pre">apt</span></code>입니다. 예전에는 <code class="docutils literal notranslate"><span class="pre">apt-get</span></code>, <code class="docutils literal notranslate"><span class="pre">apt-cache</span></code> 같이 별개의 프로그램으로 존재했지만, 현재 <code class="docutils literal notranslate"><span class="pre">apt</span></code>라는 단일 프로그램으로 합쳐지는 중입니다.</p>
<p>[^2]: Ports Tree는 엄밀히 말해서 패키지 관리자가 아니므로 본 문서에서 다루지 않습니다.</p>
</div>
<div class="section" id="id2">
<h2>결론<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>웬간한 프로그래밍 언어별, OS 별 팩키지 관리자가 하나씩 다 존재한다는 걸 슬슬 눈치채신 분들이 많을 거 같습니다. 다량의 플러그인이나, 팩키지나, 프로그램이나 라이브러리들을 설치할 때, &quot;설치 할게 정말 많네, 이거 한 방에 설치할 방법이 없을까?&quot;란 생각이 드신다면, 일단 인터넷에서 자동으로 설치하고 관리해주는 녀석을 찾는 걸 권장합니다. 이런 것들에 익숙해질수록, 설치했던거 또 설치하는 실수라던지, 업데이트가 나왔음에도 불구하고 out-dated된 녀석을 쓰는 일들은 많이 줄일 수 있을 것입니다. 또한, 개발 속도도 빨라질것입니다. 뭐 나중에는 스크립트 만들어 놓고 일정 주기로 업데이트를 한다던지, 자기가 만든 걸 등록한다던지 이런 일들을 할 수도 있겠죠.</p>
</div>
</div>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">CS Univ Wiki</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2019, benjioh5.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../../_sources/기본적인-도구들의-사용방법/개발/패키지-관리자.md.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>